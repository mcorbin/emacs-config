#+TITLE: Mathieu Corbin emacs configuration
#+AUTHOR: Mathieu Corbin
#+EMAIL: mcorbin [at] gmail [dot] com

#+begin_src
                                                              ___ __
    .-----.--------.---.-.----.-----.______.----.-----.-----.'  _|__|.-----.
    |  -__|        |  _  |  __|__ --|______|  __|  _  |     |   _|  ||  _  |
    |_____|__|__|__|___._|____|_____|      |____|_____|__|__|__| |__||___  |
                                                                     |_____|
#+end_src

Thx to vdemeester (https://github.com/vdemeester/emacs-config) !
Cette config est grandement inspirée de la sienne, encore merci à lui ;)

* General Configuration
** Appearance
*** General

   nyan-mode is fun and pretty

   #+BEGIN_SRC emacs-lisp
     (use-package nyan-mode
       :ensure t
       :config
       (progn
         (nyan-mode)
         (nyan-start-animation)))
   #+END_SRC

   Neotree can be useful

   #+BEGIN_SRC emacs-lisp
     (use-package neotree
       :ensure t
       :config
       (global-set-key [f6] 'neotree-toggle))
   #+END_SRC

   Removing toolbar/menu/scrollbar...
   #+begin_src emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (blink-cursor-mode -1)
     (setq inhibit-splash-screen t)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (line-number-mode 1)
     (column-number-mode 1)
     (global-hl-line-mode 1)
   #+END_SRC

   Limit font-lock-mode
   #+BEGIN_SRC emacs-lisp
     (setq font-lock-maximum-decoration 3)
   #+END_SRC

*** Fringe

    Customize fringe

    indicate-buffer-boundaries put arrows at the beginning/end of a buffer
    indate-empty-lines indicate in the fringe the lines at the end of a buffer.
    #+BEGIN_SRC emacs-lisp
      (setq-default indicate-buffer-boundaries 'left)
      (setq-default indicate-empty-lines +1)
    #+END_SRC

*** Whitespaces
    I want to detect trailing whitespace quickly
    #+BEGIN_SRC emacs-lisp
      (setq-default show-trailing-whitespace t)

    #+END_SRC

*** Fonts

   I use Monospace font.
   #+begin_src emacs-lisp
    (set-face-attribute 'default nil :family "Monospace" :height 140)
   #+end_src
*** Themes

    I load some custom themes and i display my theme only in graphic mode
    #+begin_src emacs-lisp
      (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")

      (if (display-graphic-p)
          (load-theme 'spolsky t))
    #+end_src

** General
   Answer y or n and not yes/no
   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'visual-line-mode)
   #+END_SRC
*** Encoding

    utf-8  by default

    #+begin_src emacs-lisp
      (set-terminal-coding-system 'utf-8)
      (set-keyboard-coding-system 'utf-8)
      (set-language-environment "UTF-8")
      (prefer-coding-system 'utf-8)
    #+end_src
*** Mouse
    move the mouse (useful for graphical term)
    #+begin_src emacs-lisp
      (mouse-avoidance-mode 'jump)
    #+end_src

*** Backup files

    Files suffixed with =~= in the current directory are ugly. We are still going to use
    backup files, as it can saves some time in case of trouble, but we'll move them
    somewhere else : ~/tmp/emacs-1001~ (for a user with the uid = 1001).

    Note the we store them in /tmp so in case of a reboot, we loose them.

    #+begin_src emacs-lisp
      (defconst emacs-tmp-dir (format "%s/%s%s/" temporary-file-directory "emacs" (user-uid)))
      (setq backup-directory-alist
            `((".*" . ,emacs-tmp-dir))
            auto-save-file-name-transforms
            `((".*" ,emacs-tmp-dir t))
            auto-save-list-file-prefix emacs-tmp-dir)
    #+end_src

    Now that all the temporary files are out of the way, we can keep more of them.

    #+begin_src emacs-lisp
      (setq delete-old-versions t
            kept-new-versions 6
            kept-old-versions 2
            version-control t)
    #+end_src

*** Buffers

    Non unique buffers name ? uniquify adds the parent path to the buffer name
    #+begin_src emacs-lisp
      (use-package uniquify)
      (setq uniquify-buffer-name-style 'forward)
    #+end_src

    Override default kill buffer function (no ask)
    #+BEGIN_SRC emacs-lisp
      (defun kill-default-buffer ()
        "Kill the currently active buffer"
        (interactive)
        (let (kill-buffer-query-functions) (kill-buffer)))

      (global-set-key (kbd "C-x k") 'kill-default-buffer)
    #+END_SRC
*** Comment/uncomment
    There is a cool function in emacs wich is =commend-dwim= (bounded
    to =M-;=. This adds a comment at the right place (at the end of
    the line, up the method, etc..

    Something I'm really use to, with IntelliJ or Eclipse, is being
    able to quickly comment a line or a region with simple
    keystroke. If nothing is selected, it comments the current line,
    if there is a selection, it comments the line selected (even if
    the selection doesn't start at the beginning of line. Let's bind
    it to =C-M-:= (=Ctrl+Alt+:=).


    #+BEGIN_SRC emacs-lisp
      (defun my/toggle-comments ()
          "A modified way to toggle comments, 'à-la' ide (intelliJ, Eclipse).
      If no region is selected, comment/uncomment the line. If a region is selected, comment/uncomment this region *but* starting from the begining of the first line of the region to the end of the last line of the region"
        (interactive)
        (save-excursion
          (if (region-active-p)
              (progn
                (setq start (save-excursion
                              (goto-char (region-beginning))
                              (beginning-of-line)
                              (point))
                      end (save-excursion
                            (goto-char (region-end))
                            (end-of-line)
                            (point)))
                (comment-or-uncomment-region start end))
            (progn
              (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
            )))
      (global-set-key (kbd "C-M-:") 'my/toggle-comments)
    #+END_SRC
*** formatting

    space instead of tabs
    #+begin_src emacs-lisp
       (setq-default indent-tabs-mode nil)
       (defcustom indent-sensitive-modes
         '(coffee-mode python-mode haml-mode yaml-mode)
         "Modes for which auto-indenting is suppressed."
         :type 'list)
    #+end_src

#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'smarter-move-beginning-of-line)
#+END_SRC

*** Async

    =async.el= is a module for doing asynchronous processing in
    Emacs. Let's load it as it's gonna be useful. Let's also load
    =dired-async= for the copy & co to be run asynchroniously (very
    useful with TRAMP).

    #+BEGIN_SRC emacs-lisp
      (use-package async
        :ensure t)
      (use-package dired-async
        :init
        (dired-async-mode 1))
    #+END_SRC

*** Dired

    #+BEGIN_SRC emacs-lisp

      (use-package dired+
                   :ensure t
                   :init)

      (use-package dired-x)
      (use-package dired-aux)

      (setq dired-listing-switches "-laGh1v --group-directories-first")


    #+END_SRC

*** selection

    expand-region

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :ensure t
        :bind ("C-=" . er/expand-region))
    #+END_SRC


*** Zoom
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-+") 'text-scale-increase)
      (global-set-key (kbd "C--") 'text-scale-decrease)
    #+END_SRC
*** scrolling
    ensure that =M-v= always undoes =C-v=, so you can go back exactly.

    #+BEGIN_SRC emacs-lisp
      (setq scroll-preserve-screen-position 'always)
    #+END_SRC
*** ace windows
    switch windows with ace-window

    #+BEGIN_SRC emacs-lisp
      (defun joe-scroll-other-window()
        (interactive)
        (scroll-other-window 1))
      (defun joe-scroll-other-window-down ()
        (interactive)
        (scroll-other-window-down 1))
      ;; From https://github.com/abo-abo/ace-window/wiki but adapted to bepo
      (use-package ace-window
        :ensure t
        :bind (("C-x C-o" . ace-window)
               ("C-x M-s" . avi-goto-word-1))
        :config
        (set-face-attribute 'aw-leading-char-face nil :foreground "deep sky blue" :weight 'bold :height 3.0)
        (set-face-attribute 'aw-mode-line-face nil :inherit 'mode-line-buffer-id :foreground "lawn green")
        (setq aw-keys   '(?q ?s ?d ?f ?j ?k ?l)
              aw-dispatch-always t
              aw-dispatch-alist
              '((?y aw-delete-window     "Ace - Delete Window")
                (?x aw-swap-window       "Ace - Swap Window")
                (?\' aw-flip-window)
                (?\. aw-split-window-vert "Ace - Split Vert Window")
                (?c aw-split-window-horz "Ace - Split Horz Window")
                (?n delete-other-windows "Ace - Maximize Window")
                (?\, delete-other-windows)
                (?u balance-windows)
                (?v winner-undo)
                (?o winner-redo)))

        (when (package-installed-p 'hydra)
          (defhydra hydra-window-size (:color red)
            "Windows size"
            ("c" shrink-window-horizontally "shrink horizontal")
            ("t" shrink-window "shrink vertical")
            ("s" enlarge-window "enlarge vertical")
            ("r" enlarge-window-horizontally "enlarge horizontal"))
          (defhydra hydra-window-frame (:color red)
            "Frame"
            ("e" make-frame "new frame")
            ("y" delete-frame "delete frame"))
          (defhydra hydra-window-scroll (:color red)
            "Scroll other window"
            ("'" joe-scroll-other-window "scroll")
            ("j" joe-scroll-other-window-down "scroll down"))
          (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
          (add-to-list 'aw-dispatch-alist '(?l hydra-window-scroll/body) t)
          (add-to-list 'aw-dispatch-alist '(?g hydra-window-frame/body) t))
        (ace-window-display-mode t)
        (winner-mode 1))
    #+END_SRC


    Use =shift + control + arrows= to change the size of windows.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "S-C-<right>") 'shrink-window-horizontally)
      (global-set-key (kbd "S-C-<left>") 'enlarge-window-horizontally)
      (global-set-key (kbd "S-C-<down>") 'enlarge-window)
      (global-set-key (kbd "S-C-<up>") 'shrink-window)
    #+END_SRC

*** Popwin

    #+BEGIN_QUOTE
    popwin is a popup window manager for Emacs which makes you free
    from the hell of annoying buffers such like *Help*, *Completions*,
    *compilation*, and etc.
    #+END_QUOTE

    That says it all, it's kind of a must.

    #+BEGIN_SRC emacs-lisp
      (use-package popwin
        :ensure t
        :config
        (progn
          (add-to-list 'popwin:special-display-config `("*Swoop*" :height 0.5 :position bottom))
          (add-to-list 'popwin:special-display-config `("*Warnings*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Procces List*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Messages*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Backtrace*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*Compile-Log*" :height 0.5 :noselect t))
          (add-to-list 'popwin:special-display-config `("*Remember*" :height 0.5))
          (add-to-list 'popwin:special-display-config `("*All*" :height 0.5))
          (add-to-list 'popwin:special-display-config `(flycheck-error-list-mode :height 0.5 :regexp t :position bottom))
          (popwin-mode 1)
          (global-set-key (kbd "C-z") popwin:keymap)))
    #+END_SRC

*** Ace Jump

    Jump to char with ace jump
    #+BEGIN_SRC emacs-lisp
      (use-package ace-jump-mode
        :ensure t
        :commands ace-jump-mode
        :bind ("C-x j" . ace-jump-mode))
    #+END_SRC

*** Highlight indentation

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indentation
        :ensure t
        :commands (highlight-indentation-mode highlight-indentation-current-column-mode)
        :config
        (progn
          (set-face-background 'highlight-indentation-face "#003308")
          (set-face-background 'highlight-indentation-current-column-face "#003308")))
    #+END_SRC
*** Evil

    For my vim coworkers
    #+BEGIN_SRC emacs-lisp
      ;;; Load undo-tree before evil for the :bind
      (use-package undo-tree
        :ensure t
        :bind (("C-*" . undo-tree-undo)))
      (use-package evil
        :ensure t
        :init)
    #+END_SRC

    Let's change the default cursor colours to easily identify wich
    mode we are in.

    #+BEGIN_SRC emacs-lisp
      (setq evil-emacs-state-cursor '("red" box))
      (setq evil-normal-state-cursor '("green" box))
      (setq evil-visual-state-cursor '("orange" box))
      (setq evil-insert-state-cursor '("red" bar))
      (setq evil-replace-state-cursor '("red" bar))
      (setq evil-operator-state-cursor '("red" hollow))
    #+END_SRC

    And define some /internals/.

    #+BEGIN_SRC emacs-lisp
      (setq evil-search-module 'evil-search)
    #+END_SRC

**** evil-leader

     The [[https://github.com/cofi/evil-leader][evil-leader]] extension provides the <leader> feature from Vim
     that provides an easy way to bind keys under a variable prefix
     key.

     #+BEGIN_SRC emacs-lisp
       (use-package evil-leader
         :ensure t
         :requires evil
         :init
         (global-evil-leader-mode t))

       (evil-leader/set-leader ",")
       (evil-leader/set-key
         "e" 'find-file
         "b" 'switch-to-buffer
         "k" 'kill-buffer)
     #+END_SRC

**** evil-args

     The [[https://github.com/wcsmith/evil-args][evil-args]] extension provides motions and text objects for
     delimited arguments in Evil.


     #+BEGIN_SRC emacs-lisp
       (use-package evil-args
         :ensure t
         :requires evil
         :config
         (progn
           ;; bind evil-args text objects
           (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
           (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)
           ;; bind evil-forward/backward-args
           (define-key evil-normal-state-map "L" 'evil-forward-arg)
           (define-key evil-normal-state-map "H" 'evil-backward-arg)
           (define-key evil-motion-state-map "L" 'evil-forward-arg)
           (define-key evil-motion-state-map "H" 'evil-backward-arg)
           ;; bind evil-jump-out-args
           (define-key evil-normal-state-map "K" 'evil-jump-out-args)
           ))
     #+END_SRC

** Server mode

   Start a server in not already running. I usually start emacs as a
   daemon when at the start of the computer, but you never know =;-)=.

   I have an error about /unsafe directory/ for =/tmp/emacs100=, that's
   why the advice is there, to ignore the error (from [[http://stackoverflow.com/a/17069276/89249][stackoverflow]]).

   #+BEGIN_SRC emacs-lisp
 (defadvice server-ensure-safe-dir (around
                                    my-around-server-ensure-safe-dir
                                    activate)
   "Ignores any errors raised from server-ensure-safe-dir"
   (ignore-errors ad-do-it))
 (unless (string= (user-login-name) "root")
   (require 'server)
   (when (or (not server-process)
            (not (eq (process-status server-process)
                   'listen)))
     (unless (server-running-p server-name)
       (server-start))))
   #+END_SRC

* Other modes
** Discover my major

   #+BEGIN_QUOTE
   Discover key bindings and their meaning for the current Emacs major mode.

   The command is inspired by discover.el and also uses the makey library. I thought, “Hey! Why not parse the information about the major mode bindings somehow and display that like discover.el does…”
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package discover-my-major
       :ensure t
       :bind ("C-h C-m" . discover-my-major))
   #+END_SRC

** Manage my minor

   Let's also use =manage-my-minor= to be able to enable/disable
   minor-modes.


   #+BEGIN_SRC emacs-lisp
     (use-package manage-minor-mode
       :ensure t
       :bind ("C-c x n" . manage-minor-mode))
   #+END_SRC

** Helm

    #+BEGIN_QUOTE
    Helm is incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when you’re looking for stuff in Emacs (like buffers, files, etc).

    Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, that’s not tied in the trap of backward compatibility.
    #+END_QUOTE

    By default the /completion/ on the selected line is done by =C-z=
    (the function is =helm-execute-persistent-action=) and =Tab= is
    used for showing action you can do on it. Let's invert them as
    =Tab= is used for completion in other tools (shells for example).

    Let's define that all helm commands will be prefixed by =C-h=,
    =C-h x= will be =Helm M-x=.

    #+begin_src emacs-lisp
      (use-package helm
        :ensure t
        :config
        (progn
          (require 'helm-config)
          (setq helm-idle-delay 0.01
                helm-input-idle-delay 0.01
                helm-buffer-max-length 40
                helm-M-x-always-save-history t
                helm-move-to-line-cycle-in-source t
                helm-ff-file-name-history-use-recentf t
                ;; Enable fuzzy matching
                helm-M-x-fuzzy-match t
                helm-buffers-fuzzy-matching t
                helm-recentf-fuzzy-match t)
          (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
          ;; Rebind actions
          (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
          (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
          (define-key helm-map (kbd "C-z") 'helm-select-action)
          (helm-autoresize-mode t)
          (helm-mode 1))
        :bind (("C-c h" . helm-command-prefix)
               ("C-x C-f" . helm-find-files)
               ("M-x" . helm-M-x)
               ("C-c b" . helm-mini)
               ("C-x C-b" . helm-buffers-list)
               ("M-y" . helm-show-kill-ring)
               ("C-x c o" . helm-occur)))
      ;; (add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
      ;; (add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile
    #+end_src

    Because it can be hard to remember all keybindings, let's use
    =helm-descbinds=.

    #+BEGIN_SRC emacs-lisp
      (use-package helm-descbinds
        :ensure t
        :defer t
        :bind ("C-h b" . helm-descbinds))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package helm-gtags
        :ensure t)
      ;; (helm-gtags-mode 1)
    #+END_SRC

*** helm-make

    #+BEGIN_SRC emacs-lisp
      (use-package helm-make
        :ensure t)
    #+END_SRC


*** helm-swoop

    =helm-swoop= is a great Helm powered buffer search/occur interface:

    #+BEGIN_SRC emacs-lisp
      (use-package helm-swoop
        :ensure t
        :defer t
        :bind (("C-S-s" . helm-swoop)
               ("M-I" . helm-swoop-back-to-last-point))
        :config
        (progn
          (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
          (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)))
    #+END_SRC
*** helm-google

    #+BEGIN_QUOTE
    Emacs Helm Interface for quick Google searches
    #+END_QUOTE

    #+BEGIN_SRC emacs-lisp
      (use-package helm-google
        :ensure t)
    #+END_SRC

** company mode
   #+BEGIN_QUOTE
   company mode
   #+END_QUOTE

   #+BEGIN_SRC emacs-lisp
   (use-package company
       :ensure t)
   (require 'company)
   (global-company-mode)
   (global-set-key (kbd "TAB") #'company-indent-or-complete-common)

   #+END_SRC

** Version control integration
*** Git
    #+begin_src emacs-lisp
      (use-package gitignore-mode
        :ensure t)
      (use-package gitconfig-mode
        :ensure t)
      (use-package gitattributes-mode
        :ensure t)
    #+end_src

**** magit

     #+begin_src emacs-lisp
       (use-package magit
         :ensure t
         :bind ("C-c g" . magit-status))
;;       (setq magit-last-seen-setup-instructions "1.4.0")
     #+end_src

***** Magit git-svn integration

      At work, I use ~git-svn~ to be able to use git locally but integrating in the
      subversion they use. Integrating ~magit~ and ~git-svn~ is a bonus but, as it
      exists, let's do it :).

      #+begin_src emacs-lisp
        (use-package magit-svn
          :ensure t)
      #+end_src

      The /quick key/ to get the ~magit-svn~ menu is ~N~.
**** git fringe decoration

     #+begin_src emacs-lisp
       (use-package git-gutter-fringe
           :ensure t
           :config (global-git-gutter-mode +1))
     #+end_src emacs-lisp

**** git-annex

     [[http://git-annex.branchable.com/][Git-annex]] is a wonderful piece of software that I use a lot in my repositories.

     #+BEGIN_QUOTE
     git-annex allows managing files with git, without checking the file contents into git. While that may seem paradoxical, it is useful when dealing with files larger than git can currently easily handle, whether due to limitations in memory, time, or disk space.
     #+END_QUOTE

     In Emacs, it integrates with magit and dired mode. The annex subcommand for magit is ~@~.

     #+begin_src emacs-lisp
       (use-package git-annex
         :ensure t)
       (use-package magit-annex
         :ensure t)
     #+end_src

**** git-timemachine
     I recently discovered an extremely cool package called git-timemachine that allows you to step though the git history of the file you’re currently editing in Emacs.

     #+BEGIN_SRC emacs-lisp
       (use-package git-timemachine
         :ensure t)
     #+END_SRC

**** git-blame

     #+BEGIN_SRC emacs-lisp
       (use-package git-blame
         :ensure t)
     #+END_SRC

** move-text

   Allows to move the current line or region up/down. The source code is
   on the Wiki: http://www.emacswiki.org/emacs/move-text.el

   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :ensure t
       :config (move-text-default-bindings))
   #+END_SRC

** Diff

   The =diff-mode= of Emacs is pretty cool, but let's show important
   whitespace when in this mode.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'diff-mode-hook (lambda ()
                                 (setq-local whitespace-style
                                             '(face
                                               tabs
                                               tab-mark
                                               spaces
                                               space-mark
                                               trailing
                                               indentation::space
                                               indentation::tab
                                               newline
                                               newline-mark))
                                 (whitespace-mode 1)))
   #+END_SRC

** Org
*** Code blocks

     We are using a lot of code block in org-mode, in this file for example ; let's
     /fontify/ the code blocks first.

     #+begin_src emacs-lisp
       (setq org-src-fontify-natively t)
     #+end_src

     Add a function to easily add a code block and bind it.

     #+begin_src emacs-lisp
              (defun my/org-insert-src-block (src-code-type)
                "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
                (interactive
                 (let ((src-code-types
                        '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
                          "calc" "dot" "gnuplot" "ledger" "R" "sass" "screen" "sql" "awk"
                          "ditaa" "haskell" "latex" "lisp" "matlab" "org" "perl" "ruby"
                          "sqlite" "rust" "scala" "golang")))
                   (list (ido-completing-read "Source code type: " src-code-types))))
                (progn
                  (newline-and-indent)
                  (insert (format "#+BEGIN_SRC %s\n" src-code-type))
                  (newline-and-indent)
                  (insert "#+END_SRC\n")
                  (previous-line 2)
                  (org-edit-src-code)))

              (add-hook 'org-mode-hook
                        '(lambda ()
                           (local-set-key (kbd "C-c s e") 'org-edit-src-code)
                           (local-set-key (kbd "C-c s i") 'my/org-insert-src-block))
                        'append)
     #+end_src

** multiple-cursors

   Multiple cursors for Emacs, this is a pretty /badass/ functionnality.

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :bind (("C-S-c C-S-c" . mc/edit-lines)
              ("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)
              ("C-c C-<" . mc/mark-all-like-this)))
   #+END_SRC

** Projectile

   #+BEGIN_QUOTE
   Projectile is a project interaction library for Emacs. Its goal is
   to provide a nice set of features operating on a project level
   without introducing external dependencies(when feasible). For
   instance - finding project files has a portable implementation
   written in pure Emacs Lisp without the use of GNU find (but for
   performance sake an indexing mechanism backed by external commands
   exists as well).
   #+END_QUOTE


   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :config
       (progn
         (setq projectile-completion-system 'default)
         (setq projectile-enable-caching nil)
         (projectile-global-mode)))
   #+END_SRC

   And let's use the helm integration too.

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t
       :config (helm-projectile-on))
   #+END_SRC

*** Perspective

    [[https://github.com/nex3/perspective-el][Perspective]] is a minor mode that provides the ability to manage
    different workspaces. It integrates well with projectile.

    #+BEGIN_SRC emacs-lisp
      (use-package perspective
        :ensure t)
      (use-package persp-projectile
        :ensure t
        :requires perspective
        :config
        (progn
          (define-key projectile-mode-map (kbd "s-s") 'projectile-persp-switch-project)
          (persp-mode)))
    #+END_SRC
** Compilation mode

   Set options and key binding for =compile=.

   #+BEGIN_SRC emacs-lisp
     (use-package compile
       :commands compile
       :bind ("<f5>" . compile)
       :config
       (progn
         (setq compilation-ask-about-save nil
               compilation-always-kill t
               compilation-scroll-output 'first-error)
         ))
   #+END_SRC


*** Compilation mode improvements

    See http://stackoverflow.com/questions/3072648/cucumbers-ansi-colors-messing-up-emacs-compilation-buffer


    #+BEGIN_SRC emacs-lisp
      (require 'ansi-color)
      (defun my/colorize-compilation-buffer ()
        (toggle-read-only)
        (ansi-color-apply-on-region (point-min) (point-max))
        (toggle-read-only))
      (add-hook 'compilation-filter-hook 'my/colorize-compilation-buffer)
    #+END_SRC

    And let's configure the compilation-mode to follow the compilation, not waiting
    at the top..

    #+BEGIN_SRC emacs-lisp
      (setq compilation-scroll-output t)
    #+END_SRC

* Languages
** Lisp

I cannot write lisp without rainbow-delimiters

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters
       :ensure t
       :config
       (progn
         (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
         (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)))

   #+END_SRC
** Lua

   #+BEGIN_SRC emacs-lisp
     (use-package lua-mode
       :ensure t)
   #+END_SRC

** Lisp(s)
*** General

    Let's install some LISP common useful modes.

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :ensure t)
      (use-package rainbow-delimiters
        :ensure t)
      (use-package highlight-parentheses
        :ensure t)
    #+END_SRC

    And define a comme lisp hook for all LISP-related prog-modes, mostly about
    parentheses.

    #+BEGIN_SRC emacs-lisp
      (defun my/lisps-mode-hook ()
        (paredit-mode t)
        (rainbow-delimiters-mode t)
        (highlight-parentheses-mode t))
    #+END_SRC

*** Emacs lisp

    #+BEGIN_SRC emacs-lisp
      (add-hook 'emacs-lisp-mode-hook
                (lambda ()
                  (my/lisps-mode-hook)
                  (eldoc-mode 1))
                )
    #+END_SRC

*** Clojure

    Clojure mode
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :config
        (progn
          (add-hook 'clojure-mode-hook 'my/lisps-mode-hook)))
    #+END_SRC

    extra clojure modes
    #+BEGIN_SRC emacs-lisp
      (use-package clj-refactor
        :ensure t)

      (defun clj-refactor-mode-hook ()
          (clj-refactor-mode 1)
          (yas-minor-mode 1) ; for adding require/use/import statements
          ;; This choice of keybinding leaves cider-macroexpand-1 unbound
          (cljr-add-keybindings-with-prefix "C-c C-m"))

      (add-hook 'clojure-mode-hook #'clj-refactor-mode-hook)

      (use-package clojure-mode-extra-font-locking
        :ensure t)

    #+END_SRC

**** cider

     Cider package with config
     #+BEGIN_SRC emacs-lisp
       (use-package cider
         :ensure t
         :config (put-clojure-indent 'match 1))

       (setq cider-repl-display-help-banner nil)
       (add-hook 'cider-repl-mode-hook
              (lambda () (setq show-trailing-whitespace nil)))
       (add-hook 'cider-repl-mode-hook 'my/lisps-mode-hook)
     #+END_SRC

** S1QL

   By default, Emacs does not automatically truncate long lines in
   SQL(i) mode, let's change that.

#+BEGIN_SRC emacs-lisp
     (add-hook 'sql-interactive-mode-hook
               (lambda ()
                 (toggle-truncate-lines t)))
#+END_SRC

** Adoc

   #+BEGIN_SRC emacs-lisp
     (use-package adoc-mode
       :ensure t)
   #+END_SRC
** Markdown, Yaml & Toml

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t)
     (use-package markdown-mode+
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t)
   #+END_SRC


   #+BEGIN_SRC emacs-lisp
     (use-package toml-mode
       :ensure t)
   #+END_SRC

** Docker

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :ensure t)
   #+END_SRC
** Vagrant

   Let's add support for vagrant.

   #+BEGIN_SRC emacs-lisp
     (use-package vagrant
       :ensure t
       :defer t
       :init
       (progn
         (evil-leader/set-key
           "VD" 'vagrant-destroy
           "Ve" 'vagrant-edit
           "VH" 'vagrant-halt
           "Vp" 'vagrant-provision
           "Vr" 'vagrant-resume
           "Vs" 'vagrant-status
           "VS" 'vagrant-suspend
           "VV" 'vagrant-up)))
   #+END_SRC

   And let's also add a TRAMP add-on for Vagrant. The idea is to be
   able to do something like =/vagrant:mybox/etc/hostname=

   #+BEGIN_SRC emacs-lisp
     (use-package vagrant-tramp
       :ensure t
       :defer t)
   #+END_SRC

** PYTHON
#+BEGIN_SRC emacs-lisp

  (use-package elpy
    :ensure t
    :init
    (progn
      (elpy-enable)))

  (use-package jedi-core
    :ensure t)

  (use-package company-jedi
    :ensure t)

  (defun my/python-mode-hook ()
    (add-to-list 'company-backends 'company-jedi))

  (add-hook 'python-mode-hook 'my/python-mode-hook)

#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp

(use-package racer
  :ensure t)

  (setq racer-cmd "~/.cargo/bin/racer")
  (setq racer-rust-src-path "/usr/local/src/rust/src")

  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)

  (add-hook 'racer-mode-hook #'company-mode)

#+END_SRC

** LATEX

#+BEGIN_SRC emacs-lisp

   (require 'tex)
   (setq TeX-auto-save t)
   (setq TeX-parse-self t)
   (setq-default TeX-master nil)

   (add-hook 'LaTeX-mode-hook 'visual-line-mode)
   (add-hook 'LaTeX-mode-hook 'flyspell-mode)
   (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)

   ;;(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  ;; (setq reftex-plug-into-AUCTeX t)

#+END_SRC

** Ocaml
#+BEGIN_SRC emacs-lisp

  (use-package tuareg
    :ensure t)

    (autoload 'tuareg-mode "tuareg" "Major mode for editing Caml code" t)
    (autoload 'camldebug "camldebug" "Run the Caml debugger" t)
    (autoload 'tuareg-imenu-set-imenu "tuareg-imenu"
    "Configuration of imenu for tuareg" t)

    (add-hook 'tuareg-mode-hook 'tuareg-imenu-set-imenu)

    ;;(setq auto-mode-alist
    ;;     (append '(("\\.ml[ily]?$" . tuareg-mode)
    ;;               ("\\.topml$" . tuareg-mode)
    ;;               auto-mode-alist)))

#+END_SRC
